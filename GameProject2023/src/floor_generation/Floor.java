package floor_generation;

import java.awt.Point;
import java.awt.geom.Point2D;
import java.io.EOFException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import framework.FileIO;
import framework.ObjectHandler;

public class Floor {

	private ObjectHandler objectHandler;

	// Contains all the available rooms which are loaded from the file system
	private List<Room> roomPool;

	// Contains the randomly generated room layout for this floor.
	// Each room's relative position is also stored here to avoid overlapping.
	private List<Room> floorRooms;
	private Map<Room, Point2D> roomPositions;

	private Room startingRoom;
	private Room currentRoom;

	/**
	 * The Floor class loads rooms from disk and combines them to procedurally generate room layouts.
	 * 
	 * The rooms are represented as an undirected graph, where each vertex represents a Room and
	 * each edge is a connection between the exits of neighboring rooms.
	 * 
	 * @param objectHandler reference to the ObjectHandler
	 */
	public Floor(ObjectHandler objectHandler) {
		this.objectHandler = objectHandler;
		roomPool = new ArrayList<>();
		floorRooms = new ArrayList<>();
		roomPositions = new HashMap<>();
		loadRooms();
	}

	/**
	 * Loads the rooms from the files generated by the level editor, creates
	 * and stores the corresponding game objects.
	 */
	public void loadRooms() {
		FileIO fileIO = new FileIO();
		try {
			for (int i = 0; ; i++) {
				int[][] bottomLayerUIDs = fileIO.loadLevel("levels/levels_bg.txt", i);
				int[][] middleLayerUIDs = fileIO.loadLevel("levels/levels.txt", i);
				int[][] topLayerUIDs = fileIO.loadLevel("levels/levels_fg.txt", i);
				int[][][] enemyWavesUIDs = new int[][][] {
					fileIO.loadLevel("levels/enemy_waves1.txt", i),
					fileIO.loadLevel("levels/enemy_waves2.txt", i),
					fileIO.loadLevel("levels/enemy_waves3.txt", i),
				};

				if (i == 0)
					startingRoom = new Room(bottomLayerUIDs, middleLayerUIDs, topLayerUIDs, enemyWavesUIDs, objectHandler);
				else
					roomPool.add(new Room(bottomLayerUIDs, middleLayerUIDs, topLayerUIDs, enemyWavesUIDs, objectHandler));
			}
		} catch (EOFException e) {
		} catch (Exception e) {
			e.printStackTrace();
		}

		currentRoom = startingRoom;
	}

	/**
	 * Procedurally generates a random floor using rooms selected from the room pool.
	 * Reaching the max room count may not be possible due to randomness.
	 * @param maxRoomCount the maximum number of rooms in the floor
	 */
	public void generateRandomFloor(int maxRoomCount) {
		// Keeps track of rooms that still have unused exits
		List<Room> leafRooms = new ArrayList<>();
		leafRooms.add(startingRoom);
		floorRooms.add(startingRoom);
		roomPositions.put(startingRoom, new Point(0, 0));

		while (!leafRooms.isEmpty() && maxRoomCount-- > 0) {
			// Randomly select a leaf room and remove it from the leaf list
			Room randomLeafRoom = getRandomElement(leafRooms);
			leafRooms.remove(randomLeafRoom);

			List<RoomDirection> availableExits = randomLeafRoom.getAvailableExitDirections();
			removeOverlappingExitDirection(availableExits, randomLeafRoom);
			if (!availableExits.isEmpty()) { 
				// Randomly select an unused exit of the randomLeafRoom
				RoomDirection selectedExit = getRandomElement(availableExits);

				// Randomly select a room from the room pool which has the opposite of the selected exit
				RoomDirection oppositeExit = RoomDirection.getOppositeDirection(selectedExit);
				Room newRoom = getRandomRoomWithExit(oppositeExit);

				if (newRoom != null) {
					// Link the currentLeafRoom and the newRoom together
					randomLeafRoom.setNeighbor(selectedExit, newRoom);
					newRoom.setNeighbor(oppositeExit, randomLeafRoom);
					floorRooms.add(newRoom);

					// Check to see if the randomLeafRoom or newRoom have more unused exits.
					// If they do, add them into the leafRooms list.
					if (!randomLeafRoom.getAvailableExitDirections().isEmpty())
						leafRooms.add(randomLeafRoom);
					if (!newRoom.getAvailableExitDirections().isEmpty()) {
						leafRooms.add(newRoom);

						Point2D newRoomPosition = calculateNewPositionBasedOnDirection(
								selectedExit,
								roomPositions.get(randomLeafRoom));
						roomPositions.put(newRoom, newRoomPosition);
					}
				}
			}
		}

		// After the floor generation is complete, close off the exits that lead to nowhere
		for (Room room : floorRooms)
			room.disableUnusedExits();
	}

	// Checks if adding a room in a direction selected from the list would cause an
	// overlap between rooms. If so, removes that direction from the list.
	private void removeOverlappingExitDirection(List<RoomDirection> roomDirections, Room room) {
		Point2D roomPosition = roomPositions.get(room);
		for (int i = roomDirections.size() - 1; i >= 0; i--) {
			RoomDirection roomDirection = roomDirections.get(i);
			Point2D neighborPosition = calculateNewPositionBasedOnDirection(roomDirection, roomPosition);
			if (roomPositions.containsValue(neighborPosition))
				roomDirections.remove(roomDirection);
		}
	}

	/**
	 * Calculates and returns new coordinates based on the given direction and room size.
	 * @param roomDirection the direction in which to calculate the new coordinates
	 * @param position the position of the center room
	 * @return a new Point2D representing the new point in the given direction
	 */
	private Point2D calculateNewPositionBasedOnDirection(RoomDirection roomDirection, Point2D position) {
		int roomX = (int) position.getX();
		int roomY = (int) position.getY();
		switch (roomDirection) {
		case None:
			break;
		case Up:
			roomY -= 1;
			break;
		case Down:
			roomY += 1;
			break;
		case Left:
			roomX -= 1;
			break;
		case Right:
			roomX += 1;
			break;
		}
		return new Point(roomX, roomY);
	}

	/**
	 * Loads the neighboring room in the given direction.
	 * @param exitDirectionToNextRoom the exiting direction towards the neighbor
	 */
	public void loadNextRoom(RoomDirection exitDirectionToNextRoom) {
		currentRoom = currentRoom.getNeighbor(exitDirectionToNextRoom);
		if (!currentRoom.areAllEnemyWavesCleared()) {
			currentRoom.lockExits();
			currentRoom.spawnNextEnemyWave();
		}
	}
	
	/**
	 * Controls when to spawn the enemy waves and when to unlock the exits.
	 */
	public void handleEnemyWaves() {
		// Unlock the exists once all waves of the current room are cleared
		if (currentRoom.areAllEnemyWavesCleared()) {
			if (currentRoom.areExitsLocked())
				currentRoom.unlockExits();
		}
		// Spawn the next wave once the current one is cleared
		else if (currentRoom.isCurrentWaveCleared()) 
			currentRoom.spawnNextEnemyWave();		
	}

	/**
	 * Retrieves a randomly selected room from the roomPool which has an exit in the given direction.
	 * @param neededExitDirection the exit direction to search for
	 * @return the room which has an exit in the required direction
	 */
	private Room getRandomRoomWithExit(RoomDirection neededExitDirection) {
		ArrayList<Room> eligibleRooms = new ArrayList<>();
		for (Room room : roomPool)
			if (room.hasExitInDirection(neededExitDirection))
				eligibleRooms.add(room);

		if (eligibleRooms.size() == 0)
			return null;

		Room randomRoom = getRandomElement(eligibleRooms);
		if (randomRoom != null)
			return randomRoom.createDeepCopy();
		else
			return null;
	}

	// Retrieves a randomly selected element from the given list.
	private <T> T getRandomElement(List<T> list) {
		if (list == null || list.isEmpty())
			return null;
		int randomIndex = (int) (Math.random() * list.size());
		return list.get(randomIndex);
	}

	public Room getCurrentRoom() {
		return currentRoom;
	}

	public void setCurrentRoom(Room currentRoom) {
		this.currentRoom = currentRoom;
	}

	public Room getStartingRoom() {
		return startingRoom;
	}
	
	public Map<Room, Point2D> getRoomPositions() {
		return roomPositions;
	}

}
