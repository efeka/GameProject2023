package level_generation;

import java.util.ArrayList;

import framework.FileIO;
import framework.ObjectHandler;

public class Floor {

	private ObjectHandler objectHandler;

	// Contains all the available rooms which are loaded from the file system
	private ArrayList<Room> roomPool;
	// Contains the randomly generated room layout for this floor
	private ArrayList<Room> floorRooms;
	private Room startingRoom;
	private Room currentRoom;

	/**
	 * The Floor class loads rooms from disk and combines them to procedurally generate room layouts.
	 * 
	 * The rooms are represented as an undirected graph, where each vertex represents a Room and
	 * each edge is a connection between the exits of neighboring rooms.
	 * 
	 * @param objectHandler reference to the ObjectHandler
	 */
	public Floor(ObjectHandler objectHandler) {
		this.objectHandler = objectHandler;
		roomPool = new ArrayList<>();
		floorRooms = new ArrayList<>();
		loadRooms();
	}

	/**
	 * Loads the rooms from the files generated by the level editor, creates
	 * and stores the corresponding game objects.
	 */
	public void loadRooms() {
		FileIO fileIO = new FileIO();
		try {
			for (int i = 0; ; i++) {
				int[][] bottomLayerUIDs = fileIO.loadLevel("levels_bg.txt", i);
				int[][] middleLayerUIDs = fileIO.loadLevel("levels.txt", i);
				int[][] topLayerUIDs = fileIO.loadLevel("levels_fg.txt", i);
				if (i == 0)
					startingRoom = new Room(bottomLayerUIDs, middleLayerUIDs, topLayerUIDs, objectHandler);
				else
					roomPool.add(new Room(bottomLayerUIDs, middleLayerUIDs, topLayerUIDs, objectHandler));
			}
		} catch (NullPointerException e) {}
		
		currentRoom = startingRoom;
	}
	
	/**
	 * Procedurally generates a random floor using rooms selected from the room pool.
	 * Reaching the max room count may not be possible due to randomness.
	 * @param maxRoomCount the maximum number of rooms in the floor
	 */
	public void generateRandomFloor(int maxRoomCount) {
		// Keeps track of rooms that still have unused exits
		ArrayList<Room> leafRooms = new ArrayList<>();
		leafRooms.add(startingRoom);
		floorRooms.add(startingRoom);

		while (!leafRooms.isEmpty() && maxRoomCount-- > 0) {
			// Randomly select a leaf room and remove it from the leaf list
			Room randomLeafRoom = getRandomElement(leafRooms);
			leafRooms.remove(randomLeafRoom);
			
			ArrayList<Direction> unusedExits = randomLeafRoom.getUnusedExitLocations();
			if (!unusedExits.isEmpty()) { 
				// Randomly select an unused exit of the randomLeafRoom
				Direction selectedExit = getRandomElement(unusedExits);
				
				// Randomly select a room from the room pool which has the opposite of the selected exit
				Direction oppositeExit = Direction.getOppositeDirection(selectedExit);
				Room newRoom = getRandomRoomWithExit(oppositeExit);
				
	            if (newRoom != null) {
	                // Link the currentLeafRoom and the newRoom together
	            	randomLeafRoom.setNeighbor(selectedExit, newRoom);
	            	newRoom.setNeighbor(oppositeExit, randomLeafRoom);
	            	floorRooms.add(newRoom);

	                // Check to see if the randomLeafRoom or newRoom have more unused exits.
	            	// If they do, add them into the leafRooms list.
	            	if (!randomLeafRoom.getUnusedExitLocations().isEmpty())
	            		leafRooms.add(randomLeafRoom);
	            	if (!newRoom.getUnusedExitLocations().isEmpty())
	            		leafRooms.add(newRoom);
	            }
			}
		}
		
		// After the floor generation is complete, close the exits
		// of the leaf rooms that lead to nowhere
		for (Room room : leafRooms)
			room.disableUnusedExits();		
	}
	
	/**
	 * Loads the neighboring room in the given direction.
	 * @param exitDirectionToNextRoom the exiting direction towards the neighbor
	 */
	public void loadNextRoom(Direction exitDirectionToNextRoom) {
		currentRoom = currentRoom.getNeighbor(exitDirectionToNextRoom);
	}
	
	/**
	 * Retrieves a randomly selected room from the roomPool which has an exit in the given direction.
	 * @param neededExitDirection the exit direction to search for
	 * @return the room which has an exit in the required direction
	 */
	private Room getRandomRoomWithExit(Direction neededExitDirection) {
		ArrayList<Room> eligibleRooms = new ArrayList<>();
		for (Room room : roomPool)
			if (room.hasExitInDirection(neededExitDirection))
				eligibleRooms.add(room);
		
		if (eligibleRooms.size() == 0)
			return null;
		
		Room randomRoom = getRandomElement(eligibleRooms);
		if (randomRoom != null)
			return randomRoom.createDeepCopy();
		else
			return null;
	}
	
	// Retrieves a randomly selected element from the given list.
	private <T> T getRandomElement(ArrayList<T> list) {
		if (list == null || list.isEmpty())
			return null;
		int randomIndex = (int) (Math.random() * list.size());
		return list.get(randomIndex);
	}
	
	public Room getCurrentRoom() {
		return currentRoom;
	}
	
	public void setCurrentRoom(Room currentRoom) {
		this.currentRoom = currentRoom;
	}

}
